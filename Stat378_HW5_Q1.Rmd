---
title: "Stat378_HW5_Q1"
output: html_document
---
This is a test change. Testing for github commit..

Below we have a function that computes matrix multiplication using for-loops.
```{python}
import numpy as np

# This function take a matrix and a np array vector in the form of 
# np.array([x1,x2,...])
def dot_product(M,x):
    xt = x.reshape(M.shape[1],1)
    y = np.zeros((M.shape[0],1))
    for i in np.arange(0,M.shape[0]):
        for j in np.arange(0,M.shape[1]):
            prod = M[i][j]*xt[j][0]
            y[i]+=prod
    return y

# This is the main function that uses the above for-loop implementation of 
#dot product to perform element-wise matrix vector multiplication and addition. 
def matrix_comp1(x):
    M = np.random.normal(loc =0, scale =1, size=(10, 10))
    N = np.random.normal(loc =0, scale =1, size=(10, 10))
    G = np.random.normal(loc =0, scale =1, size=(10, 1))
    Mx = dot_product(M,x)
    Nx = dot_product(N,x)
    return Mx+Nx+G

# Check if the function works as it should be.  
x = np.ones(10)
y = matrix_comp1(x)
#print(y)

```
Below we have a function that computes matrix multiplication using vectorized method.
```{python}
# Function A with vectorized method
import numpy as np
def matrix_comp2(x):
  xt = x.reshape(x.size,1)
  M = np.random.normal(loc =0, scale =1, size=(10, 10))
  N = np.random.normal(loc =0, scale =1, size=(10, 10))
  G = np.random.normal(loc =0, scale =1, size=(10, 1))
  Mx = np.matrix(np.dot(M,x)).T
  Nx = np.matrix(np.dot(N,x)).T
  F = np.matrix(Mx)+np.matrix(Nx)+np.matrix(G)
  return F
  
# Check if the function works as it should be.  
x = np.ones(10)
y = matrix_comp2(x)
#print(y)
```

Define a function that takes n, the number of iterations, and return computing time for the for-loop method.

```{python}
from timeit import default_timer as timer
import matplotlib.pyplot as plt

def forloop_time(n): # The function takes n iteration
    start = timer()
    for iteration in np.arange(1,n):
        x = np.random.normal(loc =0, scale =1, size=(10, 1)) # Generate a randome 10x1 vector from standard normal distribution
        matrix_comp1(x)
    end = timer()
    elapsed_time = end-start
    return elapsed_time
```

Define another function that takes n, the number of iterations, and return computing time for the vectorized method.

```{python}
#import numpy as np
def vectorized_time(n): # The function takes n iteration
    start = timer()
    for iteration in np.arange(0,n):
        x = np.random.normal(loc =0, scale =1, size=(10, 1)) # Generate a randome 10x1 vector from standard normal distribution
        matrix_comp2(x)
    end = timer()
    elapsed_time = end-start
    return elapsed_time
```

Let's compare the computing times for these two methods. Instead of computing for all number of iterations from 1 to 10000, I'll create a list of evenly spaced number of iterations (every 100 iterations until we reach 10000 iterations). I will plot the computing times to show how fast vectorized method is compared to the for-loop implementtion for each number of iterations.

```{python}
import numpy as np
# Compute time it takes to finish n iterations of for-loop function and store it to plot later.
comp_time = []
num_iterations = np.arange(0,10001,100)
for i in num_iterations:
    comp_time.append(forloop_time(i))
# Compute time it takes to finish n iterations of the vectorized function and store it to plot later.
comp_time2 = []
num_iterations = np.arange(0,10001,100)
for i in num_iterations:
    comp_time2.append(vectorized_time(i))
    
fig, ax = plt.subplots()
ax.scatter(num_iterations,comp_time2,color='green',label='vectorized')
ax.scatter(num_iterations,comp_time, color='red',label='for-loop')
plt.xlabel("Number of iterations")
plt.ylabel("Computing time (s)")
ax.legend()

```

Below I have R implementation of Function B using double for-loops.

```{r}
matrix_comp3 <- function(x){
  M = matrix(rnorm(10*10,mean=0,sd=1), 10, 10) 
  G = matrix(rnorm(10*10,mean=0,sd=1), 10, 1) 
  for(i in 1:nrow(M)) {
    for(j in 1:ncol(M)) {
      M[i,j] = M[i,j]^3
    }
  }
  H = M%*%x+G
  return(H)
}

x<-1:10
H = matrix_comp3(x)
#print(H)
```

Below I have R implementation of Function B using vectorized methods.

```{r}
matrix_comp4 <- function(x){
  M = matrix(rnorm(10*10,mean=0,sd=1), 10, 10) 
  G = matrix(rnorm(10*10,mean=0,sd=1), 10, 1) 
  M = M^3
  H = M%*%x+G
  return(H)
}

# Test code
x<-1:10
H = matrix_comp4(x)
#print(H)
```

The below function times computing time the for-loop method takes for Function B.

```{r}
library(tictoc)
tic.clearlog()
size<-c(1:100)
iter<-size*size

comp_time3 <- function(n){
  start <-Sys.time()
  for(i in 1:n) {
      x = matrix(rnorm(10*10,mean=0,sd=1), 10, 1) 
      matrix_comp3(x)
      }
  end <- Sys.time()
  time_diff <- as.numeric(end-start)
  return(time_diff)
  }

#comp_time3(500)
```
The below function times computing time the vectorized method takes for Function B.

```{r}
tic.clearlog()

comp_time4 <- function(n){
  start <-Sys.time()
  for(i in 1:n) {
      x = matrix(rnorm(10*10,mean=0,sd=1), 10, 1) 
      matrix_comp4(x)
      }
  end <- Sys.time()
  time_diff <- as.numeric(end-start)
  return(time_diff)
  }
```
These two functions time the computing time it takes for the for-loop methos and the vectorized method to perform n iterations. I created a list of equally spaced numbers from 1 to 10001 and stored the computing times to plot them in the next step.

```{r}
li <-list()
li2 <- list()
c<-seq(from = 1, to = 10001, by = 100)

for(i in c) {
  time3<-comp_time3(i)
  li<-append(li,time3)
}

#print(c)
for(i in c) {
  time4<-comp_time4(i)
  li2<-append(li2,time4)
}
```

Below is the plot for computing time it takes for the n iterations of for-loop implementaion of function B.
```{r}
plot(c,li,xlab = "Number of iterations",ylab = "Computing time (s)",main  ="For loop method")
```
Below is the plot for computing time it takes for the n iterations of the vectorized method for function B.

```{r}
plot(c,li2,xlab = "Number of iterations",ylab = "Computing time (s)",main  ="Vectorized method")
```

